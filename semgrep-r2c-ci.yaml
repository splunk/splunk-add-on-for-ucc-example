rules:
- id: contrib.nodejsscan.eval_yaml_deserialize.yaml_deserialize
  patterns:
  - pattern-inside: |
      require('js-yaml');
      ...
  - pattern: |
      $X.load(...)
  message: >-
    User controlled data in 'yaml.load()' function can result in Remote Code
    Injection.
  languages:
  - javascript
  severity: ERROR
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    dev.semgrep.actions: &id001 []
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/contrib.nodejsscan.eval_yaml_deserialize.yaml_deserialize
    semgrep.ruleset: r2c-ci
- id: contrib.nodejsscan.security_electronjs.electron_allow_http
  patterns:
  - pattern-either:
    - pattern: >
        new BrowserWindow({webPreferences: {allowRunningInsecureContent:
        true}});
    - pattern: |
        var $X = {webPreferences: {allowRunningInsecureContent: true}};
  message: >-
    Application can load content over HTTP and that makes the app vulnerable
    to Man in the middle attacks.
  languages:
  - javascript
  severity: ERROR
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/contrib.nodejsscan.security_electronjs.electron_allow_http
    semgrep.ruleset: r2c-ci
- id: contrib.nodejsscan.security_electronjs.electron_disable_websecurity
  patterns:
  - pattern-either:
    - pattern: |
        new BrowserWindow({webPreferences: {webSecurity: false}});
    - pattern: |
        var $X = {webPreferences: {webSecurity: false}};
  message: >-
    Disabling webSecurity will disable the same-origin policy and allows the
    execution of insecure code from any domain.
  languages:
  - javascript
  severity: ERROR
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-346: Origin Validation Error'
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/contrib.nodejsscan.security_electronjs.electron_disable_websecurity
    semgrep.ruleset: r2c-ci
- id: contrib.nodejsscan.xss_templates.handlebars_noescape
  patterns:
  - pattern: |
      $X.compile(..., {noEscape: true}, ...)
  message: >-
    Disabling Escaping in Handlebars is not a secure behaviour. This can
    introduce XSS vulnerabilties.
  languages:
  - javascript
  severity: ERROR
  metadata:
    owasp: 'A1: Injection'
    cwe: >-
      CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web
      Page (Basic XSS)
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/contrib.nodejsscan.xss_templates.handlebars_noescape
    semgrep.ruleset: r2c-ci
- id: contrib.nodejsscan.xss_templates.squirrelly_autoescape
  pattern: $X.autoEscaping(false)
  message: >-
    Handlebars SafeString will not escape the data passed through it.
    Untrusted user input passing through SafeString can cause XSS.
  languages:
  - javascript
  severity: ERROR
  metadata:
    owasp: 'A1: Injection'
    cwe: >-
      CWE-79: Improper Neutralization of Input During Web Page Generation
      ('Cross-site Scripting')
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/contrib.nodejsscan.xss_templates.squirrelly_autoescape
    semgrep.ruleset: r2c-ci
- id: go.grpc.security.grpc-client-insecure-connection.grpc-client-insecure-connection
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-300: Channel Accessible by Non-Endpoint'
    references:
    - https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.grpc.security.grpc-client-insecure-connection.grpc-client-insecure-connection
    semgrep.ruleset: r2c-ci
  message: >-
    Found an insecure gRPC connection using 'grpc.WithInsecure()'. This creates a
    connection without encryption to a gRPC
    server. A malicious attacker could tamper with the gRPC message, which could compromise
    the machine. Instead, establish
    a secure connection with an
    SSL certificate using the 'grpc.WithTransportCredentials()' function. You can
    create a create credentials using a 'tls.Config{}'
    struct with 'credentials.NewTLS()'. The final fix looks like this: 'grpc.WithTransportCredentials(credentials.NewTLS(<config>))'.
  languages:
  - go
  severity: ERROR
  pattern: $GRPC.Dial($ADDR, ..., $GRPC.WithInsecure(...), ...)
  fix-regex:
    regex: (.*)WithInsecure\(.*?\)
    replacement: \1WithTransportCredentials(credentials.NewTLS(<your_tls_config_here>))
- id: go.grpc.security.grpc-server-insecure-connection.grpc-server-insecure-connection
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-300: Channel Accessible by Non-Endpoint'
    references:
    - https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.grpc.security.grpc-server-insecure-connection.grpc-server-insecure-connection
    semgrep.ruleset: r2c-ci
  message: >-
    Found an insecure gRPC server without 'grpc.Creds()'. This allows for a connection
    without encryption to this server.
    A malicious attacker could tamper with the gRPC message, which could compromise
    the machine. Include credentials derived
    from an SSL certificate in order to create a secure gRPC connection. You can create
    credentials using 'credentials.NewServerTLSFromFile("cert.pem",
    "cert.key")'.
  languages:
  - go
  severity: ERROR
  patterns:
  - pattern-not: grpc.NewServer(..., grpc.Creds(...), ...)
  - pattern: grpc.NewServer(...)
- id: go.jwt-go.security.jwt.hardcoded-jwt-key
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A2: Broken Authentication'
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.jwt-go.security.jwt.hardcoded-jwt-key
    semgrep.ruleset: r2c-ci
  pattern-either:
  - pattern: |
      $X = []byte("...")
      ...
      $Y := $TOKEN.SignedString($X)
  - pattern: |
      $TOKEN.SignedString([]byte("..."))
  message: JWT token is hardcoded
  languages: [go]
  severity: WARNING
- id: go.lang.correctness.useless-eqeq.hardcoded-eq-true-or-false
  patterns:
  - pattern-either:
    - pattern: if (true) { ... }
    - pattern: if (false) { ... }
  message: useless if statement, always the same behavior
  languages: [go]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.correctness.useless-eqeq.hardcoded-eq-true-or-false
    semgrep.ruleset: r2c-ci
- id: go.lang.maintainability.useless-ifelse.useless-if-conditional
  patterns:
  - pattern-either:
    - pattern: |-
        if ($X) {
            ...
        } else if ($X) {
            ...
        }
  message: |
    Detected an if block that checks for the same condition on both branches (`$X`)
  languages: [go]
  severity: WARNING
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.maintainability.useless-ifelse.useless-if-conditional
    semgrep.ruleset: r2c-ci
- id: go.lang.maintainability.useless-ifelse.useless-if-body
  patterns:
  - pattern: |-
      if ($X) {
          $S
      } else {
          $S
      }
  message: |
    Detected identical if-statement bodies. Is this intentional?
  languages: [go]
  severity: WARNING
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.maintainability.useless-ifelse.useless-if-body
    semgrep.ruleset: r2c-ci
- id: go.lang.security.audit.crypto.bad_imports.insecure-module-used
  message: >-
    Detected use of an insecure cryptographic hashing method. This method is known
    to be broken and easily compromised. Use SHA256 or SHA3 instead.
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://godoc.org/golang.org/x/crypto/sha3
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.crypto.bad_imports.insecure-module-used
    semgrep.ruleset: r2c-ci
  languages: [go]
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern: |
        md5.$FUNC(...)
    - pattern: |
        des.$FUNC(...)
    - pattern: |
        sha1.$FUNC(...)
    - pattern: |
        rc4.$FUNC(...)
    - pattern: |-
        cgi.$FUNC(...)
- id: go.lang.security.audit.crypto.insecure_ssh.avoid-ssh-insecure-ignore-host-key
  message: |
    Disabled host key verification detected. This allows man-in-the-middle
    attacks. Use the 'golang.org/x/crypto/ssh/knownhosts' package to do
    host key verification.
    See https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
    to learn more about the problem and how to fix it.
  metadata:
    cwe: 'CWE-322: Key Exchange without Entity Authentication'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
    - https://gist.github.com/Skarlso/34321a230cf0245018288686c9e70b2d
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.crypto.insecure_ssh.avoid-ssh-insecure-ignore-host-key
    semgrep.ruleset: r2c-ci
  languages: [go]
  severity: WARNING
  pattern: |-
    ssh.InsecureIgnoreHostKey()
- id: go.lang.security.audit.crypto.ssl.ssl-v3-is-insecure
  message: |
    SSLv3 is insecure because it has known vulnerabilities.
    Starting with go1.14, SSLv3 will be removed. Instead, use
    'tls.VersionTLS13'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A9: Using Components with Known Vulnerabilities'
    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls_config.go
    references:
    - https://golang.org/doc/go1.14#crypto/tls
    - https://www.us-cert.gov/ncas/alerts/TA14-290A
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.crypto.ssl.ssl-v3-is-insecure
    semgrep.ruleset: r2c-ci
  languages: [go]
  severity: ERROR
  patterns:
  - pattern: |-
      tls.Config{..., MinVersion: $TLS.VersionSSL30, ...}
  fix-regex:
    regex: VersionSSL30
    replacement: VersionTLS13
- id: go.lang.security.audit.crypto.tls.tls-with-insecure-cipher
  message: |
    Detected an insecure CipherSuite via the 'tls' module. This suite is considered weak.
    Use the function 'tls.CipherSuites()' to get a list of good cipher suites.
    See https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
    for why and what other cipher suites to use.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A9: Using Components with Known Vulnerabilities'
    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls.go
    references:
    - https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.crypto.tls.tls-with-insecure-cipher
    semgrep.ruleset: r2c-ci
  languages: [go]
  severity: WARNING
  pattern-either:
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.CipherSuite{..., TLS_RSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_RSA_WITH_AES_128_CBC_SHA256 ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 ,...}
  - pattern: |-
      tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 ,...}
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-md5
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages: [go]
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.crypto.use_of_weak_crypto.use-of-md5
    semgrep.ruleset: r2c-ci
  pattern-either:
  - pattern: |
      md5.New()
  - pattern: |
      md5.Sum(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-sha1
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages: [go]
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.crypto.use_of_weak_crypto.use-of-sha1
    semgrep.ruleset: r2c-ci
  pattern-either:
  - pattern: |
      sha1.New()
  - pattern: |
      sha1.Sum(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-DES
  message: |
    Detected DES cipher algorithm which is insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  languages: [go]
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.crypto.use_of_weak_crypto.use-of-DES
    semgrep.ruleset: r2c-ci
  pattern-either:
  - pattern: |
      des.NewTripleDESCipher(...)
  - pattern: |
      des.NewCipher(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-rc4
  message: |
    Detected RC4 cipher algorithm which is insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  languages: [go]
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.crypto.use_of_weak_crypto.use-of-rc4
    semgrep.ruleset: r2c-ci
  pattern: |-
    rc4.NewCipher(...)
- id: go.lang.security.audit.net.dynamic-httptrace-clienttrace.dynamic-httptrace-clienttrace
  message: |
    Detected a potentially dynamic ClientTrace. This occurred because semgrep could not
    find a static definition for '$TRACE'. Dynamic ClientTraces are dangerous because
    they deserialize function code to run when certain Request events occur, which could lead
    to code being run without your knowledge. Ensure that your ClientTrace is statically defined.
  metadata:
    cwe: 'CWE-913: Improper Control of Dynamically-Managed Code Resources'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://github.com/returntocorp/semgrep-rules/issues/518
  # Detects when a static ClientTrace is not defined in the same file as
  # WithClientTrace. Not a perfect detection, but sufficiently works in a
  # scan of ~1k repos: https://dev.massive.ret2.co/triager/filter/1007
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.net.dynamic-httptrace-clienttrace.dynamic-httptrace-clienttrace
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-not-inside: |
      ...
      &httptrace.ClientTrace { ... }
      ...
  - pattern: httptrace.WithClientTrace($ANY, $TRACE)

  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.net.pprof.pprof-debug-exposure
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://github.com/securego/gosec#available-rules
    references:
    - https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.net.pprof.pprof-debug-exposure
    semgrep.ruleset: r2c-ci
  message: |
    The profiling 'pprof' endpoint is automatically exposed on /debug/pprof.
    This could leak information about the server.
    Instead, use `import "net/http/pprof"`. See
    https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
    for more information and mitigation.
  languages: [go]
  severity: WARNING
  patterns:
  - pattern-inside: |
      import _ "net/http/pprof"
      ...
  - pattern-inside: |
      func $ANY(...) {
        ...
      }
  - pattern-not: http.ListenAndServe("=~/^localhost.*/", ...)
  - pattern-not: http.ListenAndServe("=~/^127[.]0[.]0[.]1.*/", ...)
  - pattern: http.ListenAndServe(...)
- id: go.lang.security.audit.net.wip-xss-using-responsewriter-and-printf.wip-xss-using-responsewriter-and-printf
  patterns:
  - pattern-inside: |
      func $FUNC(..., $W http.ResponseWriter, ...) {
          ...
      }
  - pattern-inside: |
      ...
      var $T = "..."
      ...
      $W.Write([]byte(fmt.$PRINTF($T, ...)), ...)
  - pattern-either:
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $INTERM = $ANYTHING(..., $DATA, ...)
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $INTERM = $DATA[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $DATA, $ERR := r.URL.Query()[...]
        ...
        $INTERM = $DATA[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $DATA, $ERR := r.URL.Query()[...]
        ...
        $INTERM = $ANYTHING(..., $DATA, ...)
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $DATA, ...)))
  message: |
    Found data going from url query parameters into formatted data written to ResponseWriter.
    This could be XSS and should not be done. If you must do this, ensure your data is
    sanitized or escaped.
  metadata:
    cwe: "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site\
      \ Scripting')"
    owasp: "A7: Cross-Site Scripting ('XSS')"
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.audit.net.wip-xss-using-responsewriter-and-printf.wip-xss-using-responsewriter-and-printf
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - go
- id: go.lang.security.decompression_bomb.potential-dos-via-decompression-bomb
  message: >-
    Detected a possible denial-of-service via a zip bomb attack. By limiting the max
    bytes read, you can mitigate this attack.
    `io.CopyN()` can specify a size. Refer to https://bomb.codes/ to learn more about
    this attack and other ways to mitigate
    it.
  severity: WARNING
  languages: [go]
  patterns:
  - pattern-either:
    - pattern: io.Copy(...)
    - pattern: io.CopyBuffer(...)
  - pattern-either:
    - pattern-inside: |
        gzip.NewReader(...)
        ...
    - pattern-inside: |
        zlib.NewReader(...)
        ...
    - pattern-inside: |
        zlib.NewReaderDict(...)
        ...
    - pattern-inside: |
        bzip2.NewReader(...)
        ...
    - pattern-inside: |
        flate.NewReader(...)
        ...
    - pattern-inside: |
        flate.NewReaderDict(...)
        ...
    - pattern-inside: |
        lzw.NewReader(...)
        ...
    - pattern-inside: |
        tar.NewReader(...)
        ...
    - pattern-inside: |
        zip.NewReader(...)
        ...
    - pattern-inside: |
        zip.OpenReader(...)
        ...
  fix-regex:
    regex: (.*)(Copy|CopyBuffer)\((.*?),(.*?)(\)|,.*\))
    replacement: \1CopyN(\3, \4, 1024*1024*256)
  metadata:
    cwe: 'CWE-400: Uncontrolled Resource Consumption'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://bomb.codes/
    - https://golang.org/pkg/io/#CopyN
    - https://github.com/securego/gosec/blob/master/rules/decompression-bomb.go
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.decompression_bomb.potential-dos-via-decompression-bomb
    semgrep.ruleset: r2c-ci
- id: go.lang.security.zip.path-traversal-inside-zip-extraction
  message: File traversal when extracting zip archive
  metadata:
    cwe: |
      CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
    source_rule_url: https://github.com/securego/gosec/issues/205
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/go.lang.security.zip.path-traversal-inside-zip-extraction
    semgrep.ruleset: r2c-ci
  languages: [go]
  severity: WARNING
  patterns:
  - pattern: |-
      reader, $ERR := zip.OpenReader($ARCHIVE)
      ...
      for _, $FILE := range reader.File {
        ...
        path := filepath.Join($TARGET, $FILE.Name)
        ...
      }
- id: java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal
  metadata:
    owasp: 'A1: Injection'
    cwe: "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path\
      \ Traversal')"
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
    references:
    - https://www.owasp.org/index.php/Path_Traversal
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal
    semgrep.ruleset: r2c-ci
  message: |
    Detected a potential path traversal. A malicious actor
    could control the location of this file, to include going backwards
    in the directory with '../'. To address this, ensure that user-controlled
    variables in file paths are sanitized. You may aslso consider using a utility
    method such as org.apache.commons.io.FilenameUtils.getName(...) to only
    retrieve the file name from the path.
  patterns:
  - pattern-either:
    - pattern: |
        $RETURNTYPE $FUNC (..., @PathParam(...) $TYPE $VAR, ...) {
          ...
          new File(..., $VAR, ...);
          ...
        }
    - pattern: |-
        $RETURNTYPE $FUNC (..., @javax.ws.rs.PathParam(...) $TYPE $VAR, ...) {
          ...
          new File(..., $VAR, ...);
          ...
        }
  severity: WARNING
  languages:
  - java
- id: java.lang.correctness.eqeq.eqeq
  patterns:
  - pattern-not-inside: assert $X;
  - pattern-not-inside: |
      assert $X : $Y;
  - pattern-either:
    - pattern: $X == $X
    - pattern: $X != $X
  - pattern-not: 1 == 1
  message: |
    `$X == $X` or `$X != $X` is always true. (Unless the value compared is a float or double).
    To test if `$X` is not-a-number, use `Double.isNaN($X)`.
  languages: [java]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.correctness.eqeq.eqeq
    semgrep.ruleset: r2c-ci
- id: java.lang.correctness.no-string-eqeq.no-string-eqeq
  languages: [java]
  equivalences:
  - equivalence: $X == $Y ==> $Y == $X
  patterns:
  - pattern-not: null == (String $Y)
  - pattern: $X == (String $Y)
  message: |
    Strings should not be compared with '=='.
    This is a reference comparison operator.
    Use '.equals()' instead.
  severity: WARNING
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.correctness.no-string-eqeq.no-string-eqeq
    semgrep.ruleset: r2c-ci
- id: java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated
  message: |
    DES is considered deprecated. AES is the recommended cipher.
    Upgrade to use AES.
    See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard for more information.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DES_USAGE
    references:
    - https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated
    semgrep.ruleset: r2c-ci
  severity: WARNING
  pattern: $CIPHER.getInstance("=~/DES/.*/");
  fix: $CIPHER.getInstance("AES/GCM/NoPadding");
  languages:
  - java
- id: java.lang.security.audit.crypto.no-null-cipher.no-null-cipher
  pattern: new NullCipher(...);
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#NULL_CIPHER
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.crypto.no-null-cipher.no-null-cipher
    semgrep.ruleset: r2c-ci
  message: |
    NullCipher was detected. This will not encrypt anything;
    the cipher text will be the same as the plain text. Use
    a valid, secure cipher: Cipher.getInstance("AES/CBC/PKCS7PADDING").
    See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions
    for more information.
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector
  message: |
    Initialization Vectors (IVs) for block ciphers should be randomly generated
    each time they are used. Using a static IV means the same plaintext
    encrypts to the same ciphertext every time, weakening the strength
    of the encryption.
  metadata:
    cwe: 'CWE-329: Not Using a Random IV with CBC Mode'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#STATIC_IV
    references:
    - https://cwe.mitre.org/data/definitions/329.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages: [java]
  patterns:
  - pattern-either:
    - pattern: |
        byte[] $IV = {
            ...
        };
        ...
        new IvParameterSpec($IV, ...);
    - pattern: |
        class $CLASS {
            byte[] $IV = {
                ...
            };
            ...
            $METHOD(...) {
                ...
                new IvParameterSpec($IV, ...);
                ...
            }
        }
- id: java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DEFAULT_HTTP_CLIENT
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated
    semgrep.ruleset: r2c-ci
  message: |
    DefaultHttpClient is deprecated. Further, it does not support connections
    using TLS1.2, which makes using DefaultHttpClient a security hazard.
    Use SystemDefaultHttpClient instead, which supports TLS1.2.
  severity: WARNING
  languages: [java]
  pattern: new DefaultHttpClient(...);
  fix-regex:
    regex: DefaultHttpClient
    replacement: SystemDefaultHttpClient
- id: java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier
  message: |
    Insecure HostnameVerifier implementation detected. This will accept
    any SSL certificate with any hostname, which creates the possibility
    for man-in-the-middle attacks.
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_HOSTNAME_VERIFIER
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages: [java]
  patterns:
  - pattern-either:
    - pattern: |
        class $CLASS implements HostnameVerifier {
          ...
          public boolean verify(...) { return true; }
        }
    - pattern: |-
        new HostnameVerifier(...){
          public boolean verify(...) {
            return true;
          }
        }
- id: java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER
    references:
    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager
    semgrep.ruleset: r2c-ci
  message: |
    Detected empty trust manager implementations. This is dangerous because it accepts any
    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore
    and TrustManagerFactory isntead.
    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
    for more information.
  severity: WARNING
  languages: [java]
  patterns:
  - pattern-either:
    - pattern-inside: |
        class $CLASS implements X509TrustManager {
          ...
        }
    - pattern-inside: |
        new X509TrustManager() {
          ...
        }
    - pattern-inside: |
        class $CLASS implements X509ExtendedTrustManager {
          ...
        }
    - pattern-inside: |
        new X509ExtendedTrustManager() {
          ...
        }
  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }
  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }
  - pattern-either:
    - pattern: public void checkClientTrusted(...) {}
    - pattern: public void checkServerTrusted(...) {}
    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }
- id: java.lang.security.audit.crypto.weak-hash.use-of-md5
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages: [java]
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_MD5
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.crypto.weak-hash.use-of-md5
    semgrep.ruleset: r2c-ci
  pattern-either:
  - pattern: |
      MessageDigest $VAR = $MD.getInstance("MD5");
  - pattern: |
      $DU.getMd5Digest().digest(...)
- id: java.lang.security.audit.crypto.weak-hash.use-of-sha1
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages: [java]
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_SHA1
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.crypto.weak-hash.use-of-sha1
    semgrep.ruleset: r2c-ci
  pattern-either:
  - pattern: |
      MessageDigest $VAR = $MD.getInstance("SHA1");
  - pattern: |
      $DU.getSha1Digest().digest(...)
- id: java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection
  metadata:
    cwe: 'CWE-297: Improper Validation of Certificate with Host Mismatch'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_SMTP_SSL
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection
    semgrep.ruleset: r2c-ci
  message: |
    Insecure SMTP connection detected. This connection will trust any SSL certificate.
    Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'.
  severity: WARNING
  patterns:
  - pattern-not-inside: |
      $EMAIL.setSSLCheckServerIdentity(true);
      ...
  - pattern-inside: |
      $EMAIL = new SimpleEmail(...);
      ...
  - pattern: |-
      $EMAIL.send(...);
  languages:
  - java
- id: java.lang.security.audit.permissive-cors.permissive-cors
  message: |
    https://find-sec-bugs.github.io/bugs.htm#PERMISSIVE_CORS
    Permissive CORS policy will allow a malicious application to communicate with the victim application in an inappropriate way, leading to spoofing, data theft, relay and other attacks.
  severity: WARNING
  languages: [java]
  pattern-either:
  - pattern: |
      HttpServletResponse $RES = ...;
      ...
      $RES.addHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      HttpServletResponse $RES = ...;
      ...
      $RES.setHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      ServerHttpResponse $RES = ...;
      ...
      $RES.getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      HttpHeaders $HEADERS = ...;
      ...
      $HEADERS.set("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      ServerWebExchange $SWE = ...;
      ...
      $SWE.getResponse().getHeaders().add("Access-Control-Allow-Origin", "*");
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.addHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.setHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: |
      $X $METHOD(...,ServerHttpResponse $RES,...) {
        ...
        $RES.getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: |
      $X $METHOD(...,ServerWebExchange $SWE,...) {
        ...
        $SWE.getResponse().getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: ResponseEntity.$RES().header("=~/access-control-allow-origin/i", "=~/^*|null$/i")
  - pattern: ServerResponse.$RES().header("=~/access-control-allow-origin/i", "=~/^*|null$/i")
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.permissive-cors.permissive-cors
    semgrep.ruleset: r2c-ci
- id: java.lang.security.audit.weak-ssl-context.weak-ssl-context
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source_rule_url: https://find-sec-bugs.github.io/bugs.htm#SSL_CONTEXT
    references:
    - https://tools.ietf.org/html/rfc7568
    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.audit.weak-ssl-context.weak-ssl-context
    semgrep.ruleset: r2c-ci
  message: |
    An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions
    are considered weak encryption and are deprecated.
    Use SSLContext.getInstance("TLSv1.2") for the best security.
  severity: WARNING
  languages: [java]
  patterns:
  - pattern-not: SSLContext.getInstance("TLS1.3")
  - pattern-not: SSLContext.getInstance("TLS1.2")
  - pattern: SSLContext.getInstance("...")
  fix-regex:
    regex: (.*?)\.getInstance\(.*?\)
    replacement: \1.getInstance("TLS1.2")
- id: java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal
  metadata:
    cwe: "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path\
      \ Traversal')"
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
    references:
    - https://www.owasp.org/index.php/Path_Traversal
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal
    semgrep.ruleset: r2c-ci
  message: |
    Detected a potential path traversal. A malicious actor
    could control the location of this file, to include going backwards
    in the directory with '../'. To address this, ensure that user-controlled
    variables in file paths are sanitized. You may aslso consider using a utility
    method such as org.apache.commons.io.FilenameUtils.getName(...) to only
    retrieve the file name from the path.
  patterns:
  - pattern-inside: |
      $RETURNTYPE $FUNC (..., HttpServletRequest $REQ, ...) {
        ...
      }
  - pattern-either:
    - pattern: |
        $VAR = ($TYPE)$REQ.getParameter(...);
        ...
        new File(..., $VAR, ...);
    - pattern: |
        $VAR = $REQ.getParameter(...);
        ...
        new File(..., $VAR, ...);
  severity: ERROR
  languages:
  - java
- id: java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss
  message: |
    Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'. User
    input was detected going directly from the HttpServletRequest into output. Ensure your
    data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'.
  metadata:
    cwe: "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site\
      \ Scripting')"
    owasp: "A7: Cross-Site Scripting ('XSS')"
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_SERVLET
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss
    semgrep.ruleset: r2c-ci
  severity: ERROR
  patterns:
  - pattern-inside: $TYPE $FUNC(..., HttpServletResponse $RESP, ...) { ... }
  - pattern-inside: $VAR = $REQ.getParameter(...); ...
  - pattern-either:
    - pattern: $RESP.getWriter(...).write(..., $VAR, ...);
    - pattern: |
        $WRITER = $RESP.getWriter(...);
        ...
        $WRITER.write(..., $VAR, ...);
  languages:
  - java
- id: java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled
  severity: ERROR
  metadata:
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    owasp: 'A4: XML External Entities (XXE)'
    references:
    - https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled
    semgrep.ruleset: r2c-ci
  message: |
    XML external entities are enabled for this XMLInputFactory. This is vulnerable to XML external entity
    attacks. Disable external entities by setting "javax.xml.stream.isSupportingExternalEntities" to false.
  pattern: $XMLFACTORY.setProperty("javax.xml.stream.isSupportingExternalEntities",
    true);
  languages:
  - java
- id: java.rmi.security.server-dangerous-object-deserialization.server-dangerous-object-deserialization
  severity: ERROR
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/
    - https://frohoff.github.io/appseccali-marshalling-pickles/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/java.rmi.security.server-dangerous-object-deserialization.server-dangerous-object-deserialization
    semgrep.ruleset: r2c-ci
  message: |
    Using an arbitrary object ('Object $PARAM') with Java RMI is an insecure deserialization
    vulnerability. This object can be manipulated by a malicious actor allowing them to execute
    code on your system. Instead, use an integer ID to look up your object, or consider alternative
    serializiation schemes such as JSON.
  patterns:
  - pattern: |
      interface $INTERFACE extends Remote {
        $RETURNTYPE $METHOD(Object $PARAM) throws RemoteException;
      }
  languages:
  - java
- id: javascript.grpc.security.grpc-nodejs-insecure-connection.grpc-nodejs-insecure-connection
  message: |
    Found an insecure gRPC connection. This creates a connection without encryption to a gRPC client/server. A malicious attacker
    could tamper with the gRPC message, which could compromise the machine.
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/javascript.grpc.security.grpc-nodejs-insecure-connection.grpc-nodejs-insecure-connection
    semgrep.ruleset: r2c-ci
  severity: ERROR
  languages: [javascript]
  pattern-either:
  - pattern: |
      require('grpc');
      ...
      $GRPC($ADDR,...,$CREDENTIALS.createInsecure(),...);
  - pattern: |-
      require('grpc');
      ...
      $CREDS = <... $CREDENTIALS.createInsecure() ...>;
      ...
      $GRPC($ADDR,...,$CREDS,...);
- id: javascript.jose.security.jwt-exposed-credentials.jwt-exposed-credentials
  languages:
  - javascript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    references:
    - https://cwe.mitre.org/data/definitions/522.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/javascript.jose.security.jwt-exposed-credentials.jwt-exposed-credentials
    semgrep.ruleset: r2c-ci
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  patterns:
  - pattern-either:
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign({password:...},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign({password:...},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {password:...};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {password:...};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {password:...};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {password:...};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.password = ...;
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.password = ...;
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {$U:{password:...}};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {$U:{password:...}};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {$U:{password:...}};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {$U:{password:...}};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.$U.password = ...;
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.$U.password = ...;
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
  severity: ERROR
- id: javascript.jose.security.jwt-hardcode.hardcoded-jwt-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/javascript.jose.security.jwt-hardcode.hardcoded-jwt-secret
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-either:
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        JWT.verify($P, "...", ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign($P, "...", ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.verify($P, "...", ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        JWT.verify($P, JWK.asKey("..."), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $KEY = JWK.asKey("...");
        ...
        JWT.verify($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $T = JWT.sign($P, JWK.asKey("..."), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $T = JWT.verify($P, JWK.asKey("..."), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $KEY = JWK.asKey("...");
        ...
        var $T = JWT.sign($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $KEY = JWK.asKey("...");
        ...
        var $T = JWT.verify($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        JWT.verify($P, $SECRET, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.sign($P, $SECRET, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.verify($P, $SECRET, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        JWT.verify($P, JWK.asKey($SECRET), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $KEY = JWK.asKey($SECRET);
        ...
        JWT.verify($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.sign($P, JWK.asKey($SECRET), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $KEY = JWK.asKey($SECRET);
        ...
        var $T = JWT.sign($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.verify($P, JWK.asKey($SECRET), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $KEY = JWK.asKey($SECRET);
        ...
        var $T = JWT.verify($P, $KEY, ...);
  languages: [javascript]
  severity: ERROR
- id: javascript.jose.security.jwt-none-alg.jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/javascript.jose.security.jwt-none-alg.jwt-none-alg
    semgrep.ruleset: r2c-ci
  languages: [javascript]
  severity: ERROR
  patterns:
  - pattern-either:
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $T = JWT.verify($P, JWK.None,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        $T = JWT.verify($P, JWK.None,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        JWT.verify($P, JWK.None,...);
- id: javascript.jsonwebtoken.security.jwt-exposed-credentials.jwt-exposed-credentials
  languages:
  - javascript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    references:
    - https://cwe.mitre.org/data/definitions/522.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/javascript.jsonwebtoken.security.jwt-exposed-credentials.jwt-exposed-credentials
    semgrep.ruleset: r2c-ci
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  patterns:
  - pattern-either:
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign({password:...},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign({password:...},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign({password:...},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {password:...};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {password:...};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {password:...};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {password:...};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {password:...};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {password:...};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.password = ...;
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.password = ...;
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.password = ...;
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {$U:{password:...}};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {$U:{password:...}};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {$U:{password:...}};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {$U:{password:...}};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {$U:{password:...}};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {$U:{password:...}};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.$U.password = ...;
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.$U.password = ...;
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.$U.password = ...;
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
  severity: ERROR
- id: javascript.jsonwebtoken.security.jwt-hardcode.hardcoded-jwt-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/javascript.jsonwebtoken.security.jwt-hardcode.hardcoded-jwt-secret
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-either:
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.verify($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.verify($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        var $T = $JWT.sign($P, $SECRET, ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        var $T = $JWT.verify($P, $SECRET, ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        $JWT.sign($P, $SECRET, ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        $JWT.verify($P, $SECRET, ...);
  languages: [javascript]
  severity: ERROR
- id: javascript.jsonwebtoken.security.jwt-none-alg.jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/javascript.jsonwebtoken.security.jwt-none-alg.jwt-none-alg
    semgrep.ruleset: r2c-ci
  languages: [javascript]
  severity: ERROR
  patterns:
  - pattern-either:
          # jsonwebtoken
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
    - pattern: |-
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
- id: javascript.lang.correctness.useless-eqeq.eqeq-is-bad
  patterns:
  - pattern-not-inside: assert(...)
  - pattern-either:
    - pattern: $X == $X
    - pattern: $X != $X
  - pattern-not: 1 == 1
  message: |
    Detected a useless comparison operation `$X == $X` or `$X != $X`. This
    operation is always true.
    If testing for floating point NaN, use `math.isnan`, or
    `cmath.isnan` if the number is complex.
  languages:
  - javascript
  - typescript
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/javascript.lang.correctness.useless-eqeq.eqeq-is-bad
    semgrep.ruleset: r2c-ci
- id: python.boto3.security.hardcoded-token.hardcoded-token
  message: |
    Hardcoded AWS access token detected. Use environment variables
    to access tokens (e.g., os.environ.get(...)) or use non version-controlled
    configuration files.
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://pypi.org/project/flake8-boto3/
    references:
    - https://bento.dev/checks/boto3/hardcoded-access-token/
    - https://aws.amazon.com/blogs/security/what-to-do-if-you-inadvertently-expose-an-aws-access-key/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.boto3.security.hardcoded-token.hardcoded-token
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-either:
    - pattern: $W(..., aws_secret_access_key="=~/^[A-Za-z0-9/+=]+$/", ...)
    - pattern: $W(..., aws_access_key_id="=~/^AKI/", ...)
    - pattern: $W(..., aws_session_token="...", ...)
  languages: [python]
  severity: WARNING
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-blowfish
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.Blowfish(...)
  message: |
    Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L96
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://sweet32.info/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-blowfish
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-idea
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.IDEA(...)
  message: |
    Detected IDEA cipher algorithm which is considered insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L98
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://tools.ietf.org/html/rfc5469
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-idea
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-rc4
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.ARC4(...)
  message: |
    Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L94
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
    - https://sweet32.info/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-rc4
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
  pattern: cryptography.hazmat.primitives.ciphers.modes.ECB(...)
  message: |
    Detected ECB cipher mode which is considered insecure. The algorithm can
    potentially leak information about the plaintext. Use CBC mode instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L101
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B305
    references:
    - https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
  pattern: cryptography.hazmat.primitives.hashes.MD5(...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
  pattern: cryptography.hazmat.primitives.hashes.SHA1(...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insufficient-ec-key-size.insufficient-ec-key-size
  patterns:
  - pattern-inside: cryptography.hazmat.primitives.asymmetric.ec.generate_private_key(...)
  - pattern-either:
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECP192R1
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163K1
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163R2
  message: |
    Detected an insufficient curve size for EC. NIST recommends
    a key size of 224 or higher. For example, use 'ec.SECP256R1'.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py
    references:
    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf
    - https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/#elliptic-curves
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.cryptography.security.insufficient-ec-key-size.insufficient-ec-key-size
    semgrep.ruleset: r2c-ci
  languages: [python]
  severity: WARNING
- id: python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references: https://docs.python.org/3/library/pickle.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization
    semgrep.ruleset: r2c-ci
  message: Avoid using insecure deserialization library, backed by `pickle`, `_pickle`,
    `cpickle`, `dill`, `shelve`, or `yaml`, which are known to lead to remote code
    execution vulnerabilities.
  languages:
  - python
  severity: ERROR
  patterns:
  - pattern-inside: |
      def $X(..., request, ...):
        ...
  - pattern-either:
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        pickle.$FUNC(<... $VAR ...>)
    - pattern: pickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        _pickle.$FUNC(<... $VAR ...>)
    - pattern: _pickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        cPickle.$FUNC(<... $VAR ...>)
    - pattern: cPickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        dill.$FUNC(<... $VAR ...>)
    - pattern: dill.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        shelve.$FUNC(<... $VAR ...>)
    - pattern: shelve.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        yaml.$FUNC(<... $VAR ...>)
    - pattern: yaml.$FUNC(<... request.$Y.get(...) ...>)
- id: python.django.security.injection.code.globals-misuse-code-execution.globals-misuse-code-execution
  message: |
    Found request data as an index to 'globals()'. This is extremely
    dangerous because it allows an attacker to execute arbirary code
    on the system. Refactor your code not to use 'globals()'.
  metadata:
    cwe: "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static\
      \ Code Injection')"
    owasp: 'A1: Injection'
    references:
    - https://github.com/mpirnat/lets-be-bad-guys/blob/d92768fb3ade32956abd53bd6bb06e19d634a084/badguys/vulnerable/views.py#L181-L186
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.django.security.injection.code.globals-misuse-code-execution.globals-misuse-code-execution
    semgrep.ruleset: r2c-ci
  languages: [python]
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
- id: python.django.security.injection.code.user-eval.user-eval
  message: |
    Found user data in a call to 'eval'. This is extremely dangerous because
    it can enable an attacker to execute remote code. See
    https://owasp.org/www-community/attacks/Code_Injection for more information
  metadata:
    cwe: "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code\
      \ ('Eval Injection')"
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.django.security.injection.code.user-eval.user-eval
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-either:
    - pattern: eval(..., request.$W.get(...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        eval(..., $V, ...)
    - pattern: eval(..., request.$W(...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        eval(..., $V, ...)
    - pattern: eval(..., request.$W[...], ...)
    - pattern: |
        $V = request.$W[...]
        ...
        eval(..., $V, ...)
  languages: [python]
  severity: WARNING
- id: python.django.security.injection.code.user-exec.user-exec
  message: |
    Found user data in a call to 'exec'. This is extremely dangerous because
    it can enable an attacker to execute remote code. See
    https://owasp.org/www-community/attacks/Code_Injection for more information.
  metadata:
    cwe: "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code\
      \ ('Eval Injection')"
    owasp: 'A1: Injection'
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.django.security.injection.code.user-exec.user-exec
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-either:
    - pattern: exec(..., request.$W.get(...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        exec(..., $V, ...)
    - pattern: exec(..., request.$W(...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        exec(..., $V, ...)
    - pattern: exec(..., request.$W[...], ...)
    - pattern: |
        $V = request.$W[...]
        ...
        exec(..., $V, ...)
  languages: [python]
  severity: WARNING
- id: python.django.security.injection.mass-assignment.mass-assignment
  languages: [python]
  severity: WARNING
  message: |
    Mass assignment detected. This can result in assignment to
    model fields that are unintended and can be exploited by
    an attacker. Instead of using '**request.$W', assign each field you
    want to edit individually to prevent mass assignment. You can read
    more about mass assignment at
    https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html.
  metadata:
    cwe: 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
      Attributes'
    owasp: 'A1: Injection'
    owaspapi: 'API6: Mass Assignment'
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.django.security.injection.mass-assignment.mass-assignment
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-either:
    - pattern: $MODEL.objects.create(**request.$W)
    - pattern: |
        $OBJ.update(**request.$W)
        ...
        $OBJ.save()
- id: python.django.security.passwords.use-none-for-password-default.use-none-for-password-default
  message: |
    '$VAR' is using the empty string as its default and is being used to set
    the password on '$MODEL'. If you meant to set an unusable password, set
    the default value to 'None' or call 'set_unusable_password()'.
  metadata:
    cwe: 'CWE-521: Weak Password Requirements'
    owasp: 'A2: Broken Authentication'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/contrib/auth/#django.contrib.auth.models.User.set_password
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.django.security.passwords.use-none-for-password-default.use-none-for-password-default
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-either:
    - pattern: |
        $VAR = request.$W.get($X, "")
        ...
        $MODEL.set_password($VAR)
        ...
        $MODEL.save(...)
    - pattern: |
        def $F(..., $VAR="", ...):
          ...
          $MODEL.set_password($VAR)
  fix-regex:
    regex: (def.*|request.*)(""|'')
    replacement: \1None
  languages: [python]
  severity: ERROR
- id: python.flask.security.dangerous-template-string.dangerous-template-string
  patterns:
  - pattern-either:
    - pattern: |
        $V = "...".format(...)
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = "...".format(...)
        ...
        return flask.render_template_string($V, ...), $MORE
    - pattern: |
        $V = "..." % $S
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = "..." % $S
        ...
        return flask.render_template_string($V, ...), $MORE
    - pattern: |
        $V = "..."
        ...
        $V += $O
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = "..."
        ...
        $V += $O
        ...
        return flask.render_template_string($V, ...), $MORE
    - pattern: |
        $V = f"...{$X}..."
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = f"...{$X}..."
        ...
        return flask.render_template_string($V, ...), $CODE
  message: |
    Found a template created with string formatting.
    This is susceptible to server-side template injection
    and cross-site scripting attacks.
  metadata:
    cwe: "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static\
      \ Code Injection')"
    owasp: 'A1: Injection'
    references:
    - https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html
    - https://pequalsnp-team.github.io/cheatsheet/flask-jinja2-ssti
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.flask.security.dangerous-template-string.dangerous-template-string
    semgrep.ruleset: r2c-ci
  languages: [python]
  severity: ERROR
- id: python.flask.security.injection.os-system-injection.os-system-injection
  languages:
  - python
  severity: ERROR
  message: User data detected in os.system. This could be vulnerable to a command
    injection and should be avoided. If this must be done, use the 'subprocess' module
    instead and pass the arguments as a list.
  metadata:
    cwe: "CWE-78: Improper Neutralization of Special Elements used in an OS Command\
      \ ('OS Command Injection')"
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Command_Injection
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.flask.security.injection.os-system-injection.os-system-injection
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: os.system(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            os.system(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: os.system(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: os.system(..., <... flask.request.$W[...] ...>, ...)
        - pattern: os.system(..., <... flask.request.$W(...) ...>, ...)
        - pattern: os.system(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
          - pattern: os.system(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
          - pattern: os.system(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
          - pattern: os.system(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
          - pattern: os.system(..., <... $INTERM ...>, ...)
- id: python.flask.security.injection.path-traversal-open.path-traversal-open
  languages:
  - python
  severity: ERROR
  message: Found request data in a call to 'open'. Ensure the request data is validated
    or sanitized, otherwise it could result in path traversal attacks.
  metadata:
    cwe: "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path\
      \ Traversal')"
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Path_Traversal
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.flask.security.injection.path-traversal-open.path-traversal-open
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: open(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            open(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: open(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: open(..., <... flask.request.$W[...] ...>, ...)
        - pattern: open(..., <... flask.request.$W(...) ...>, ...)
        - pattern: open(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
          - pattern: open(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
          - pattern: open(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
          - pattern: open(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
          - pattern: open(..., <... $INTERM ...>, ...)
- id: python.flask.security.injection.ssrf-requests.ssrf-requests
  languages:
  - python
  severity: ERROR
  message: Data from request object is passed to a new server-side request. This could
    lead to a server-side request forgery (SSRF). To mitigate, ensure that schemes
    and hosts are validated against a whitelist, do not forward the response to the
    user, and ensure proper authentication and transport-layer security in the proxied
    request.
  metadata:
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Server_Side_Request_Forgery
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.flask.security.injection.ssrf-requests.ssrf-requests
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $ROUTE_FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: requests.$FUNC(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            requests.$FUNC(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: requests.$FUNC(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: requests.$FUNC(..., <... flask.request.$W[...] ...>, ...)
        - pattern: requests.$FUNC(..., <... flask.request.$W(...) ...>, ...)
        - pattern: requests.$FUNC(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
          - pattern: requests.$FUNC(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
          - pattern: requests.$FUNC(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
          - pattern: requests.$FUNC(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
          - pattern: requests.$FUNC(..., <... $INTERM ...>, ...)
- id: python.flask.security.injection.user-eval.eval-injection
  languages:
  - python
  severity: ERROR
  message: Detected user data flowing into eval. This is code injection and should
    be avoided.
  metadata:
    cwe: "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code\
      \ ('Eval Injection')"
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.flask.security.injection.user-eval.eval-injection
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: eval(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            eval(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: eval(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: eval(..., <... flask.request.$W[...] ...>, ...)
        - pattern: eval(..., <... flask.request.$W(...) ...>, ...)
        - pattern: eval(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
          - pattern: eval(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
          - pattern: eval(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
          - pattern: eval(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
          - pattern: eval(..., <... $INTERM ...>, ...)
- id: python.flask.security.injection.user-exec.exec-injection
  languages:
  - python
  severity: ERROR
  message: |
    Found user data in a call to 'exec'. This is extremely dangerous because
    it can enable an attacker to execute remote code.
  metadata:
    cwe: "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code\
      \ ('Eval Injection')"
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Code_Injection
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.flask.security.injection.user-exec.exec-injection
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: exec(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            exec(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: exec(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: exec(..., <... flask.request.$W[...] ...>, ...)
        - pattern: exec(..., <... flask.request.$W(...) ...>, ...)
        - pattern: exec(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
          - pattern: exec(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
          - pattern: exec(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
          - pattern: exec(..., <... $INTERM ...>, ...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
          - pattern: exec(..., <... $INTERM ...>, ...)
- id: python.flask.security.insecure-deserialization.insecure-deserialization
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.flask.security.insecure-deserialization.insecure-deserialization
    semgrep.ruleset: r2c-ci
  message: |
    Detected the use of an insecure deserizliation library in a Flask route. These libraries
    are prone to code execution vulnerabilities. Ensure user data does not enter this function.
    To fix this, try to avoid serializing whole objects. Consider instead using a serializer
    such as JSON.
  languages:
  - python
  severity: ERROR
  patterns:
  - pattern-inside: |
      @app.route(...)
      def $X(...):
        ...
  - pattern-not: $MODULE.$FUNC("...")
  - pattern-not: $MODULE.$FUNC(open("...", ...))
  - pattern-either:
    - pattern: pickle.$FUNC(...)
    - pattern: _pickle.$FUNC(...)
    - pattern: cPickle.$FUNC(...)
    - pattern: dill.$FUNC(...)
    - pattern: shelve.$FUNC(...)
    - pattern: yaml.load(...)
- id: python.jinja2.security.audit.autoescape-disabled.autoescape-disabled
  patterns:
  - pattern-not: jinja2.Environment(..., autoescape=True, ...)
  - pattern-not: jinja2.Environment(..., autoescape=jinja2.select_autoescape(...),
      ...)
  - pattern: jinja2.Environment(...)
  fix-regex:
    regex: (.*)\)
    replacement: \1, autoescape=True)
  message: >-
    Detected a Jinja2 environment without autoescaping. Jinja2 does not autoescape
    by default.
    This is dangerous if you are rendering to a browser because this allows for cross-site
    scripting (XSS) attacks. If you are in a web context, enable autoescaping by setting
    'autoescape=True.' You may also consider using 'jinja2.select_autoescape()' to
    only enable
    automatic escaping for certain file extensions.
  metadata:
    cwe: 'CWE-116: Improper Encoding or Escaping of Output'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://jinja.palletsprojects.com/en/2.11.x/api/#basics
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.jinja2.security.audit.autoescape-disabled.autoescape-disabled
    semgrep.ruleset: r2c-ci
  languages: [python]
  severity: WARNING
- id: python.lang.correctness.common-mistakes.default-mutable-dict.default-mutable-dict
  patterns:
  - pattern-either:
    - patterns:
      - pattern: |
          def $F(..., $D={}, ...):
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {}
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict(...)
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D.copy()
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.copy($D)
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict.copy($D)
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {... for ... in ...}
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D or {}
            ...
            $D[...] = ...
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D={}, ...):
              ...
              $D[...] = ...
    - patterns:
      - pattern: |
          def $F(..., $D={}, ...):
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {}
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict(...)
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D.copy()
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.copy($D)
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict.copy($D)
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {... for ... in ...}
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D or {}
            ...
            $D.update(...)
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D={}, ...):
              ...
              $D.update(...)
    - patterns:
      - pattern: |
          def $F(..., $D={}, ...):
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {}
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict(...)
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D.copy()
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.copy($D)
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict.copy($D)
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {... for ... in ...}
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D or {}
            ...
            $D.setdefault(...)
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D={}, ...):
              ...
              $D.setdefault(...)
  message: Function $F mutates default dict $D. Instances of default function arguments
    in Python are shared between function calls.  Mutating a default function argument
    changes the result for all function consumers. This will most likely cause unexpected
    results, or lead to security vulnerabilities whereby one function consumer can
    either view or modify the data of another function consumer.
  languages: [python]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.common-mistakes.default-mutable-dict.default-mutable-dict
    semgrep.ruleset: r2c-ci
- id: python.lang.correctness.common-mistakes.default-mutable-list.default-mutable-list
  patterns:
  - pattern-either:
    - patterns:
      - pattern: |
          def $F(..., $D=[], ...):
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = []
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [...]
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list(...)
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.copy($D)
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list.copy($D)
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D[:]
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [... for ... in ...]
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D or []
            ...
            $D.append(...)
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D=[], ...):
              ...
              $D.append(...)
    - patterns:
      - pattern: |
          def $F(..., $D=[], ...):
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = []
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [...]
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list(...)
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.copy($D)
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list.copy($D)
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D[:]
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [... for ... in ...]
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D or []
            ...
            $D.extend(...)
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D=[], ...):
              ...
              $D.extend(...)
    - patterns:
      - pattern: |
          def $F(..., $D=[], ...):
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = []
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [...]
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list(...)
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.copy($D)
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list.copy($D)
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D[:]
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [... for ... in ...]
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D or []
            ...
            $D.insert(...)
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D=[], ...):
              ...
              $D.insert(...)
  message: Function $F mutates default list $D. Instances of default function arguments
    in Python are shared between function calls.  Mutating a default function argument
    changes the result for all function consumers. This will most likely cause unexpected
    results, or lead to security vulnerabilities whereby one function consumer can
    either view or modify the data of another function consumer.
  languages: [python]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.common-mistakes.default-mutable-list.default-mutable-list
    semgrep.ruleset: r2c-ci
- id: python.lang.correctness.common-mistakes.is-comparison-string.string-is-comparison
  patterns:
  - pattern-not: $S is None
  - pattern-not: type($X) is $T
  - pattern-not: $S is True
  - pattern-not: $S is False
  - pattern-not: $S is ""
  - pattern-either:
    - pattern: $S is "..."
    - pattern: '"..." is $S'
  message: |
    Found string comparison using 'is' operator. The 'is' operator
    is for reference equality, not value equality, and therefore should
    not be used to compare strings. For more information, see
    https://github.com/satwikkansal/wtfpython#-how-not-to-use-is-operator"
  languages: [python]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.common-mistakes.is-comparison-string.string-is-comparison
    semgrep.ruleset: r2c-ci
- id: python.lang.correctness.common-mistakes.is-not-is-not.is-not-is-not
  patterns:
  - pattern: $S is (not ...)
  message: In python 'X is not ...' is different from 'X is (not ...)'. In the latter
    the 'not' converts the '...' directly to boolean.
  languages: [python]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.common-mistakes.is-not-is-not.is-not-is-not
    semgrep.ruleset: r2c-ci
- id: python.lang.correctness.dict-modify-iterating.dict-del-while-iterate
  patterns:
  - pattern-either:
    - pattern: |
        for $KEY, $VALUE in $DICT.items():
            ...
            del $DICT[$KEY]
    - pattern: |
        for $KEY in $DICT.keys():
            ...
            del $DICT[$KEY]
  message: 'It appears that `$DICT[$KEY]` is a dict with items being deleted while
    in a for loop. This is usually a bad idea and will likely lead to a RuntimeError:
    dictionary changed size during iteration'
  languages: [python]
  severity: WARNING
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.dict-modify-iterating.dict-del-while-iterate
    semgrep.ruleset: r2c-ci
- id: python.lang.correctness.list-modify-iterating.list-modify-while-iterate
  patterns:
  - pattern-either:
    - pattern: |
        for $ELEMENT in $LIST:
          ...
          $LIST.pop(...)
    - pattern: |
        for $ELEMENT in $LIST:
          ...
          $LIST.push(...)
    - pattern: |
        for $ELEMENT in $LIST:
          ...
          $LIST.append(...)
    - pattern: |
        for $ELEMENT in $LIST:
          ...
          $LIST.extend(...)
  message: |
    It appears that `$LIST` is a list that is being modified while in a for loop.
    This will likely cause a runtime error or an infinite loop.
  languages: [python]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.list-modify-iterating.list-modify-while-iterate
    semgrep.ruleset: r2c-ci
- id: python.lang.correctness.return-in-init.return-in-init
  patterns:
  - pattern-inside: |
      class A(...):
          ...
          def __init__(...):
              ...
  - pattern: return ...
  message: '`return` should never appear inside a class __init__ function. This will
    cause a runtime error.'
  languages: [python]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.return-in-init.return-in-init
    semgrep.ruleset: r2c-ci
- id: python.lang.correctness.return-in-init.yield-in-init
  patterns:
  - pattern-inside: |
      class $A(...):
          ...
  - pattern-inside: |
      def __init__(...):
          ...
  - pattern-either:
    - pattern: |
        yield ...
    - pattern: |
        yield
  message: '`yield` should never appear inside a class __init__ function. This will
    cause a runtime error.'
  languages: [python]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.return-in-init.yield-in-init
    semgrep.ruleset: r2c-ci
- id: python.lang.correctness.tempfile.flush.tempfile-without-flush
  pattern-either:
  - patterns:
    - pattern-not-inside: |
        $F = tempfile.NamedTemporaryFile(...)
        ...
        $F.write(...)
        ...
        $F.flush()
        ...
        $F.name
    - pattern-not-inside: |
        $F = tempfile.NamedTemporaryFile(...)
        ...
        $F.write(...)
        ...
        $F.close()
        ...
        $F.name
    - pattern-not-inside: |
        $F = tempfile.NamedTemporaryFile(..., delete=False, ...)
        ...
        $F.close()
        ...
        $F.name
    - pattern-inside: |
        $F = tempfile.NamedTemporaryFile(...)
        ...
    - pattern: |
        $F.name
  - patterns:
    - pattern-not-inside: |
        with tempfile.NamedTemporaryFile(...) as $F:
            ...
            $F.write(...)
            ...
            $F.flush()
            ...
            $F.name
    - pattern-not-inside: |
        with tempfile.NamedTemporaryFile(...) as $F:
            ...
            $F.write(...)
            ...
            $F.close()
            ...
            $F.name
    - pattern-inside: |
        with tempfile.NamedTemporaryFile(...) as $F:
            ...
    - pattern: |
        $F.name
  message: >-
    Using '$F.name' without '.flush()' or '.close()' may cause an error because the
    file may not exist
    when '$F.name' is used. Use '.flush()' or close the file before using '$F.name'.
  languages: [python]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.tempfile.flush.tempfile-without-flush
    semgrep.ruleset: r2c-ci
- id: python.lang.correctness.useless-comparison.no-strings-as-booleans
  patterns:
  - pattern-either:
    - pattern: |
        if <... "..." and ... ...>:
            ...
    - pattern: |
        if <... "..." or ... ...>:
            ...
    - patterns:
      - pattern-not: |
          if $X in "...":
            ...
      - pattern: |
          if "...":
              ...
  message: |
    Using strings as booleans in Python has unexpected results.
    `"one" and "two"` will return "two".
    `"one" or "two"` will return "one".
     In Python, strings are truthy, evaluating to True.
  languages: [python]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.useless-comparison.no-strings-as-booleans
    semgrep.ruleset: r2c-ci
- id: python.lang.correctness.useless-eqeq.useless-eqeq
  patterns:
  - pattern-not-inside: |
      def __eq__(...):
          ...
  - pattern-not-inside: |
      def __cmp__(...):
          ...
  - pattern-not-inside: assert(...)
  - pattern-not-inside: assert ...
  - pattern-not-inside: assert ..., ...
  - pattern-not-inside: assertTrue(...)
  - pattern-not-inside: assertFalse(...)
  - pattern-either:
    - pattern: $X == $X
    - pattern: $X != $X
  - pattern-not: 1 == 1
  message: >-
    This expression is always True: `$X == $X` or `$X != $X`.
    If testing for floating point NaN, use `math.isnan($X)`,
    or `cmath.isnan($X)` if the number is complex.
  languages: [python]
  severity: ERROR
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.correctness.useless-eqeq.useless-eqeq
    semgrep.ruleset: r2c-ci
- id: python.lang.maintainability.useless-ifelse.useless-if-conditional
  patterns:
  - pattern-either:
    - pattern: |
        if $X:
            ...
        elif $X:
            ...
  message: if block checks for the same condition on both branches (`$X`)
  languages: [python]
  severity: WARNING
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.maintainability.useless-ifelse.useless-if-conditional
    semgrep.ruleset: r2c-ci
- id: python.lang.maintainability.useless-literal.useless-literal-dict
  patterns:
  - pattern-either:
    - pattern: |
        {..., $X: $A, ..., $X: $B, ...}
    - pattern: |
        dict(..., ($X, $A), ..., ($X, $B), ...)
  message: key `$X` is uselessly assigned twice
  languages: [python]
  severity: WARNING
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.maintainability.useless-literal.useless-literal-dict
    semgrep.ruleset: r2c-ci
- id: python.lang.security.audit.weak-ssl-version.weak-ssl-version
  patterns:
  - pattern-either:
    - pattern: ssl.PROTOCOL_SSLv2
    - pattern: ssl.PROTOCOL_SSLv3
    - pattern: ssl.PROTOCOL_TLSv1
    - pattern: ssl.PROTOCOL_TLSv1_1
    - pattern: pyOpenSSL.SSL.SSLv2_METHOD
    - pattern: pyOpenSSL.SSL.SSLv23_METHOD
    - pattern: pyOpenSSL.SSL.SSLv3_METHOD
    - pattern: pyOpenSSL.SSL.TLSv1_METHOD
    - pattern: pyOpenSSL.SSL.TLSv1_1_METHOD
  message: |
    An insecure SSL version was detected. TLS versions 1.0, 1.1, and all SSL versions
    are considered weak encryption and are deprecated.
    Use 'ssl.PROTOCOL_TLSv1_2' or higher.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/insecure_ssl_tls.py#L30
    references:
    - https://tools.ietf.org/html/rfc7568
    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
    - https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLSv1_2
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.security.audit.weak-ssl-version.weak-ssl-version
    semgrep.ruleset: r2c-ci
  languages: [python]
  severity: WARNING
- id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
  pattern: hashlib.md5(...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
  pattern: hashlib.sha1(...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.lang.security.unquoted-csv-writer.unquoted-csv-writer
  patterns:
  - pattern-not: csv.writer(..., quoting=csv.QUOTE_ALL, ...)
  - pattern: csv.writer(...)
  message: Found an unquoted CSV writer. This is susceptible to injection. Use 'quoting=csv.QUOTE_ALL'.
  metadata:
    cwe: 'CWE-1236: Improper Neutralization of Formula Elements in a CSV File'
    owasp: 'A1: Injection'
    references:
    - https://affinity-it-security.com/how-to-prevent-csv-injection/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.security.unquoted-csv-writer.unquoted-csv-writer
    semgrep.ruleset: r2c-ci
  fix-regex:
    regex: (.*)\)
    replacement: \1, quoting=csv.QUOTE_ALL)
  languages: [python]
  severity: ERROR
- id: python.lang.security.unverified-ssl-context.unverified-ssl-context
  pattern: ssl._create_unverified_context(...)
  message: |
    Unverified SSL context detected. This will permit insecure connections without verifying
    SSL certificates. Use 'ssl.create_default_context()' instead.
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-295: Improper Certificate Validation'
    references:
    - https://docs.python.org/3/library/ssl.html#ssl-security
    - https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.security.unverified-ssl-context.unverified-ssl-context
    semgrep.ruleset: r2c-ci
  severity: ERROR
  languages:
  - python
- id: python.lang.security.use-defused-xml.use-defused-xml
  pattern-either:
  - pattern: import xml
  - pattern: import lxml
  fix-regex:
    regex: (xml|lmxl)
    replacement: defusedxml
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    references:
    - https://docs.python.org/3/library/xml.html
    - https://github.com/tiran/defusedxml
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.security.use-defused-xml.use-defused-xml
    semgrep.ruleset: r2c-ci
  message: |
    Found use of the native Python XML libraries, which is vulnerable to XML external entity (XXE)
    attacks. The Python documentation recommends the 'defusedxml' library instead. Use 'defusedxml'.
    See https://github.com/tiran/defusedxml for more information.
  languages: [python]
  severity: ERROR
- id: python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc
  pattern-either:
  - pattern: import xmlrpclib
  - pattern: import SimpleXMLRPCServer
  - pattern: import xmlrpc
  message: |
    Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities.
    Use defusedxml.xmlrpc instead.
  metadata:
    cwe: "CWE-776: Improper Restriction of Recursive Entity References in DTDs ('XML\
      \ Entity Expansion')"
    owasp: 'A4: XML External Entities (XXE)'
    source-rule-url: https://github.com/PyCQA/bandit/blob/07f84cb5f5e7c1055e6feaa0fe93afa471de0ac3/bandit/blacklists/imports.py#L160
    references:
    - https://pypi.org/project/defusedxml/
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc
    semgrep.ruleset: r2c-ci
  severity: ERROR
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-blowfish
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.Blowfish.new(...)
    - pattern: Crypto.Cipher.Blowfish.new(...)
  message: |
    Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://sweet32.info/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-blowfish
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-des
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.DES.new(...)
    - pattern: Crypto.Cipher.DES.new(...)
  message: |
    Detected DES cipher algorithm which is considered insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://tools.ietf.org/html/rfc5469
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-des
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc2
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.ARC2.new(...)
    - pattern: Crypto.Cipher.ARC2.new
  message: |
    Detected RC2 cipher algorithm which is considered insecure. The algorithm has known vulnerabilities and is difficult to use securely. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://security.stackexchange.com/questions/93924/is-rc2-cbc-at-all-secure
    - https://sweet32.info/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc2
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc4
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.ARC4.new(...)
    - pattern: Crypto.Cipher.ARC4.new(...)
  message: |
    Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
    - https://sweet32.info/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc4
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-xor
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.XOR.new(...)
    - pattern: Crypto.Cipher.XOR.new(...)
  message: |
    Detected XOR cipher algorithm which is considered insecure. This algorithm
    is not cryptographically secure and can be reversed easily. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-xor
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md2
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD2.new(...)
    - pattern: Cryptodome.Hash.MD2.new (...)
  message: |
    Detected MD2 hash algorithm which is considered insecure. This algorithm
    has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6149
    - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2409
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md2
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md4
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD4.new(...)
    - pattern: Cryptodome.Hash.MD4.new (...)
  message: |
    Detected MD4 hash algorithm which is considered insecure. This algorithm
    has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6150
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md4
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md5
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD5.new(...)
    - pattern: Cryptodome.Hash.MD5.new (...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md5
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-sha1
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.SHA.new(...)
    - pattern: Cryptodome.Hash.SHA.new (...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-sha1
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - python
- id: python.requests.security.disabled-cert-validation.disabled-cert-validation
  patterns:
  - pattern-either:
    - pattern: requests.put(..., verify=False, ...)
    - pattern: requests.patch(..., verify=False, ...)
    - pattern: requests.delete(..., verify=False, ...)
    - pattern: requests.head(..., verify=False, ...)
    - pattern: requests.options(..., verify=False, ...)
    - pattern: requests.request(..., verify=False, ...)
    - pattern: requests.get(..., verify=False, ...)
    - pattern: requests.post(..., verify=False, ...)
  message: |
    Certificate verification has been explicitly disabled. This
    permits insecure connections to insecure servers. Re-enable
    certification validation.
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://stackoverflow.com/questions/41740361/is-it-safe-to-disable-ssl-certificate-verification-in-pythonss-requests-lib
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.requests.security.disabled-cert-validation.disabled-cert-validation
    semgrep.ruleset: r2c-ci
  languages: [python]
  severity: ERROR
- id: python.requests.security.no-auth-over-http.no-auth-over-http
  patterns:
  - pattern-either:
    - pattern: requests.$W("=~/http:\/\/.*/", ..., auth=$X, ...)
    - pattern: |
        $URL = "=~/http:\/\/.../"
        ...
        requests.$W($URL, ..., auth=$X, ...)
  fix-regex:
    regex: http:\/\/
    replacement: https://
    count: 1
  message: |
    Authentication detected over HTTP. HTTP does not provide any
    encryption or protection for these authentication credentials.
    This may expose these credentials to unauthhorized parties.
    Use 'https://' instead.
  metadata:
    cwe: 'CWE-523: Unprotected Transport of Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://pypi.org/project/flake8-flask/
    references:
    - https://blog.r2c.dev/2020/bento-check-no-auth-over-http/
    - https://bento.dev/checks/requests/no-auth-over-http/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/python.requests.security.no-auth-over-http.no-auth-over-http
    semgrep.ruleset: r2c-ci
  languages: [python]
  severity: ERROR
- id: ruby.jwt.security.jwt-exposed-credentials.ruby-jwt-exposed-credentials
  languages:
  - ruby
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    references:
    - https://cwe.mitre.org/data/definitions/522.html
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.jwt.security.jwt-exposed-credentials.ruby-jwt-exposed-credentials
    semgrep.ruleset: r2c-ci
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern: |
      $PAYLOAD = {...,password:...,...}
      ...
      JWT.encode($PAYLOAD,...)
  severity: ERROR
- id: ruby.jwt.security.jwt-none-alg.ruby-jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.jwt.security.jwt-none-alg.ruby-jwt-none-alg
    semgrep.ruleset: r2c-ci
  languages: [ruby]
  severity: ERROR
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern: |
      JWT.encode($PAYLOAD, $SECRET, 'none', ...)
- id: ruby.jwt.security.jwt-hardcode.ruby-jwt-hardcoded-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.jwt.security.jwt-hardcode.ruby-jwt-hardcoded-secret
    semgrep.ruleset: r2c-ci
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern-either:
    - pattern: |
        JWT.encode($PAYLOAD,"...",...)
    - pattern: |
        JWT.decode($PAYLOAD,"...",...)
    - pattern: |
        JWT.encode($PAYLOAD,nil,...)
    - pattern: |
        JWT.decode($PAYLOAD,nil,...)
    - pattern: |
        $SECRET = "..."
        ...
        JWT.encode($PAYLOAD,$SECRET,...)
    - pattern: |
        $SECRET = "..."
        ...
        JWT.decode($PAYLOAD,$SECRET,...)
  languages: [ruby]
  severity: ERROR
- id: ruby.lang.security.ssl-mode-no-verify.ssl-mode-no-verify
  pattern: OpenSSL::SSL::VERIFY_NONE
  message: |
    Detected SSL that will accept an unverified connection.
    This makes the connections susceptible to man-in-the-middle attacks.
    Use 'OpenSSL::SSL::VERIFY_PEER' intead.
  fix-regex:
    regex: VERIFY_NONE
    replacement: VERIFY_PEER
  severity: WARNING
  languages:
  - ruby
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.ssl-mode-no-verify.ssl-mode-no-verify
    semgrep.ruleset: r2c-ci
- id: ruby.lang.security.hardcoded-http-auth-in-controller.hardcoded-http-auth-in-controller
  pattern: |
    class $CONTROLLER < ApplicationController
      ...
      http_basic_authenticate_with ..., :password => "...", ...
    end
  message: |
    Detected hardcoded password used in basic authentication in a controller
    class. Including this password in version control could expose this
    credential. Consider refactoring to use environment variables or
    configuration files.
  severity: ERROR
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/basic_auth/index.markdown
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.hardcoded-http-auth-in-controller.hardcoded-http-auth-in-controller
    semgrep.ruleset: r2c-ci
  languages:
  - ruby
- id: ruby.lang.security.filter-skipping.filter-skipping
  patterns:
  - pattern-not: |
      $CALL "=~/.*(/:action.*).*/", $ACTION
  - pattern: |
      $CALL "=~/.*(/:action.*).*/"
  message: |
    Checks for use of action in Ruby routes. This can cause Rails to render an arbitrary view if an
    attacker creates an URL accurately. Affects 3.0 applications. Can avoid the vulnerability by providing
    additional constraints.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_filter_skipping.rb
    - https://groups.google.com/g/rubyonrails-security/c/NCCsca7TEtY
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.filter-skipping.filter-skipping
    semgrep.ruleset: r2c-ci
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.missing-csrf-protection.missing-csrf-protection
  patterns:
  - pattern: |
      class $CONTROLLER < ActionController::Base
        ...
      end
  - pattern-not: |
      class $CONTROLLER < ActionController::Base
        ...
        protect_from_forgery :with => :exception
      end
  - pattern-not: |
      class $CONTROLLER < ActionController::Base
        ...
        protect_from_forgery prepend: true, with: :exception
      end
  message: |
    Detected controller which does not enable cross-site request forgery
    protections using 'protect_from_forgery'. Add
    'protect_from_forgery :with => :exception' to your controller class.
  severity: ERROR
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/cross-site_request_forgery/index.markdown
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.missing-csrf-protection.missing-csrf-protection
    semgrep.ruleset: r2c-ci
  languages:
  - ruby
- id: ruby.lang.security.bad-deserialization.bad-deserialization
  patterns:
  - pattern-either:
    - pattern: |
        YAML.load(...)
    - pattern: |
        CSV.load(...)
    - pattern: |
        Marshal.load(...)
    - pattern: |
        Marshal.restore(...)
    - pattern: |
        $OBJ.object_load(...)
  - pattern-not: |
      YAML.load(..., safe: true, ...)
  message: |
    Checks for unsafe deserialization. Objects in Ruby can be serialized into strings,
    then later loaded from strings. However, uses of load and object_load can cause remote code execution.
    Loading user input with YAML, MARSHAL, or CSV can potentially be dangerous. Use JSON securely instead.
  metadata:
    references:
    - https://groups.google.com/g/rubyonrails-security/c/61bkgvnSGTQ/m/nehwjA8tQ8EJ
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_deserialize.rb
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.bad-deserialization.bad-deserialization
    semgrep.ruleset: r2c-ci
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.force-ssl-false.force-ssl-false
  patterns:
  - pattern: |
      config.force_ssl = false
  message: |
    Checks for configuration setting of force_ssl to false. Force_ssl forces usage of HTTPS, which
    could lead to network interception of unencrypted application traffic. To fix, set config.force_ssl = true.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_force_ssl.rb
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.force-ssl-false.force-ssl-false
    semgrep.ruleset: r2c-ci
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.mass-assignment-protection-disabled.mass-assignment-protection-disabled
  pattern: $MODEL.new(params[...], ..., :without_protection => true, ...)
  message: |
    Mass assignment protection disabled for '$MODEL'. This could
    permit assignment to sensitive model fields without intention. Instead,
    use 'attr_accessible' for the model or disable mass assigment using
    'config.active_record.whitelist_attributes = true'.
    ':without_protection => true' must be removed for this to take effect.
  metadata:
    cwe: 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
      Attributes'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/mass_assignment/index.markdown
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.mass-assignment-protection-disabled.mass-assignment-protection-disabled
    semgrep.ruleset: r2c-ci
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.file-disclosure.file-disclosure
  patterns:
  - pattern: |
      config.serve_static_assets = true
  message: |
    Special requests can determine whether a file exists on a filesystem that's outside the Ruby app's
    root directory. To fix this, set config.serve_static_assets = false.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_file_disclosure.rb
    - https://groups.google.com/g/rubyonrails-security/c/23fiuwb1NBA/m/MQVM1-5GkPMJ
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.file-disclosure.file-disclosure
    semgrep.ruleset: r2c-ci
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.jruby-xml.jruby-xml
  patterns:
  - pattern: |
      XmlMini.backend = $STR
  - pattern-not: |
      XmlMini.backend = "REXML"
  message: |
    The JDOM backend for XmlMini has a vulnerability that lets an attacker perform a denial of service attack
    or gain access to files on the application server. This affects versions 3.0, but is fixed in versions
    3.1.12 and 3.2.13. To fix, either upgrade or use XmlMini.backend="REXML".
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_jruby_xml.rb
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.jruby-xml.jruby-xml
    semgrep.ruleset: r2c-ci
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.yaml-parsing.yaml-parsing
  patterns:
  - pattern: ActionController::Base.param_parsers[Mime::YAML] = :yaml
  message: |
    Detected enabled YAML parsing. This is vulnerable to remote code execution in Rails 2.x
    versions up to 2.3.14. To fix, delete this line.
  fix-regex:
    regex: ActionController.*:yaml
    replacement: ' '
  severity: WARNING
  languages:
  - ruby
  metadata:
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.yaml-parsing.yaml-parsing
    semgrep.ruleset: r2c-ci
- id: ruby.lang.security.json-entity-escape.json-entity-escape
  pattern-either:
  - pattern: |
      ActiveSupport.escape_html_entities_in_json = false
  - pattern: |
      config.active_support.escape_html_entities_in_json = false
  message: |
    Checks if HTML escaping is globally disabled for JSON output. This could lead to XSS.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_json_entity_escape.rb
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.json-entity-escape.json-entity-escape
    semgrep.ruleset: r2c-ci
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.divide-by-zero.divide-by-zero
  patterns:
  - pattern-either:
    - pattern: |
        $X / 0
    - pattern: |
        $ZERO = 0
        ...
        $X / $ZERO
  message: |
    Checks for divide by zero. Best practice involves not dividing a variable by zero, as this leads to a Ruby
    ZeroDivisionError.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_divide_by_zero.rb
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.lang.security.divide-by-zero.divide-by-zero
    semgrep.ruleset: r2c-ci
  languages:
  - ruby
  severity: WARNING
- id: ruby.rails.security.audit.xss.templates.alias-for-html-safe.alias-for-html-safe
  message: ''
  metadata:
    references:
    - https://medium.com/sumone-technical-blog/a-pretty-way-to-unescape-html-in-a-ruby-on-rails-application-efc22b850027
    - https://stackoverflow.com/questions/4251284/raw-vs-html-safe-vs-h-to-unescape-html#:~:text===
    dev.semgrep.actions: *id001
    semgrep.policy:
      id: 1618
      name: Getting Started
      slug: getting-started
    semgrep.url: https://semgrep.dev/r/ruby.rails.security.audit.xss.templates.alias-for-html-safe.alias-for-html-safe
    semgrep.ruleset: r2c-ci
  languages: [none]
  paths:
    include:
    - '*.erb'
  severity: WARNING
  pattern-regex: <%==.*?%>
